<shaders>
	<shader name="VortexStreet">
		<parameters>
			<param name="Enabled" type="float"/>
			<param name="Time" type="float"/>
		</parameters>
		<vertex><![CDATA[
			attribute vec3 Position;    // Required
			attribute vec4 Color;       // Required
			attribute vec2 TexCoord;    // Required
			attribute vec4 RenderData;  // Required
			attribute float Scale;      // Required
			attribute float Enabled;
			attribute float Time;
			varying vec4 Color0;
			varying vec2 TexCoord0;
			varying vec4 RenderDataOut;
			varying float ScaleOut;
			varying float EnabledOut;
			varying float TimeOut;
			uniform mat4 Transform;     // Required
			void main(void)
			{
				RenderDataOut = RenderData;
				ScaleOut = Scale;			// Passing data to fragment shader
				EnabledOut = Enabled;	    // Passing data to fragment shader
				TimeOut = Time;				// Passing data to fragment shader
				Color0 = Color;
				TexCoord0 = TexCoord;
				gl_Position = Transform * vec4(Position.xyz, 1.0);
			}
		]]></vertex>
		<fragment><![CDATA[
			varying lowp vec4 Color0;           // Required
            varying mediump vec2 TexCoord0;     // Required
            varying lowp vec4 RenderDataOut;    // Required
			varying lowp float ScaleOut;        // Required
			varying lowp float EnabledOut;      // Required
			varying lowp float TimeOut;
			uniform sampler2D Texture0;         // Required

			const vec4 cHashA4 = vec4 (0., 1., 57., 58.);
			const vec3 cHashA3 = vec3 (1., 57., 113.);
			const float cHashM = 43758.54;

			vec4 Hashv4f (float p)
			{
			  return fract (sin (p + cHashA4) * cHashM);
			}

			float Noisefv2 (vec2 p)
			{
			  vec2 i = floor (p);
			  vec2 f = fract (p);
			  f = f * f * (3. - 2. * f);
			  vec4 t = Hashv4f (dot (i, cHashA3.xy));
			  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);
			}

			float Fbm2 (vec2 p)
			{
			  float s = 0.;
			  float a = 1.;
			  for (int i = 0; i < 6; i ++) {
				s += a * Noisefv2 (p);
				a *= 0.5;
				p *= 2.;
			  }
			  return s;
			}

			float tCur;

			vec2 VortF (vec2 q, vec2 c)
			{
			  vec2 d = q - c;
			  return 0.25 * vec2 (d.y, - d.x) / (dot (d, d) + 0.05);
			}

			vec2 FlowField (vec2 q)
			{
			  vec2 vr, c;
			  float dir = 1.;
			  c = vec2 (mod (tCur, 10.) - 20., 0.6 * dir);
			  vr = vec2 (0.);
			  for (int k = 0; k < 30; k ++) {
				vr += dir * VortF (4. * q, c);
				c = vec2 (c.x + 1., - c.y);
				dir = - dir;
			  }
			  return vr;
			}


			void main(void)
			{
				float height = 0.05f;
				float speed = 0.005f;
				vec4 Color = Color0 * texture2D(Texture0, TexCoord0);
				if(EnabledOut==1 && Color.r == 0.0f && Color.g == 0.0f && Color.b == 0.0f){
					vec2 uv = gl_FragCoord.xy / RenderDataOut.xy - 0.5;
					uv.x *= RenderDataOut.x / RenderDataOut.y;
					tCur = TimeOut * speed;
					vec2 p = uv;
					for (int i = 0; i < 10; i ++) p -= FlowField (p) * height;
					vec3 col = Fbm2 (5. * p + vec2 (-0.1 * tCur, 0.)) * vec3 (0.5, 0.5, 1.);
					Color = vec4 (col, 1.);
				}
				gl_FragColor = Color;
			}
		]]></fragment>
	</shader>
</shaders>
